// SPDX-FileCopyrightText: (c) 2025 Rafal Zajac <rzajac@gmail.com>
// SPDX-License-Identifier: MIT

// Package mocker provides a tool for generating interface mocks.
package mocker

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"io"
	"strings"
)

// Generate creates a mock implementation for the specified interface name and
// writes it to the configured output.
func Generate(name string, opts ...Option) error {
	return New().Generate(name, opts...)
}

// Sentinel errors.
var (
	// ErrUnkPkg is returned when a directory or an import path does not point
	// to a valid Go package.
	//
	// This error occurs in the following cases:
	//   - The provided path cannot be resolved to a valid import path.
	//   - The import path cannot be resolved to a valid directory.
	ErrUnkPkg = errors.New("package not found")

	// ErrUnkType is returned when a type declaration cannot be found.
	ErrUnkType = errors.New("type not found")

	// ErrUnkItf is returned when an interface cannot be found.
	ErrUnkItf = errors.New("interface not found")

	// ErrUnkMet is returned when an interface method cannot be found.
	ErrUnkMet = errors.New("method not found")

	// ErrAstParse is returned when AST parsing encounters an error.
	ErrAstParse = errors.New("error parsing sources")

	// ErrNoMethods is returned when the interface to mock has no methods.
	ErrNoMethods = errors.New("interface has no methods")
)

// Mocker represents the main structure for creating interface mocks.
type Mocker struct {
	res *resolver // Package cache.
}

// New creates a new [Mocker] instance.
func New() *Mocker { return &Mocker{res: &resolver{}} }

// Generate creates a mock implementation for the specified interface name and
// writes it to the configured output.
func (mck *Mocker) Generate(name string, opts ...Option) error {
	cfg, err := newConfig(name, opts...)
	if err != nil {
		return err
	}
	var created bool
	cfg, created, err = cfg.create()
	if err != nil {
		return err
	}
	itf, err := mck.run(cfg)
	if err != nil {
		return err
	}
	if len(itf.methods) == 0 {
		return ErrNoMethods
	}

	buf := bytes.NewBuffer(make([]byte, 0, 10*1024))
	if !created {
		_, _ = fmt.Fprintf(buf, "package %s", cfg.tgtPkg.pkgName)
	}
	buf.WriteString("\n\n")
	buf.WriteString("// Code generated by mocker. DO NOT EDIT.")
	buf.WriteString("\n\n")

	mckImp := &gopkg{pkgName: assumedPackageName(selfImp), pkgPath: selfImp}
	tstImp := &gopkg{pkgName: assumedPackageName(testerImp), pkgPath: testerImp}
	tstImp.setAlias(cfg.testerAlias)
	imps := append(itf.imports(), mckImp, tstImp)

	buf.WriteString(genImports(imps))
	buf.WriteString("\n\n")
	const format = "type %s struct {\n\t*mock.Mock\n\tt %s.T\n}"
	_, _ = fmt.Fprintf(buf, format, cfg.tgtName, tstImp.pkgName)
	buf.WriteString("\n\n")
	buf.WriteString(mck.genConstructor(cfg.tgtName, tstImp.pkgName))
	buf.WriteString("\n\n")
	buf.WriteString(itf.generate(cfg.tgtName, cfg.onHelpers))
	buf.WriteString("\n")
	if _, err = buf.WriteTo(cfg.tgtOut); err != nil {
		return err
	}
	if c, ok := cfg.tgtOut.(io.Closer); ok {
		return c.Close()
	}
	return nil
}

// run runs mocker for a given configuration without generating code for the
// mock.
func (mck *Mocker) run(cfg Config) (*goitf, error) {
	fil, astItf, err := cfg.srcPkg.findItf(cfg.srcName)
	if err != nil {
		return nil, err
	}
	cfg.srcFile = fil
	cfg.srcItf = astItf

	mts, err := mck.methods(cfg)
	if err != nil {
		return nil, err
	}
	itf := &goitf{
		name:    cfg.srcName,
		methods: mts,
	}
	return itf, nil
}

// methods parses code for source interface methods.
func (mck *Mocker) methods(cfg Config) ([]*method, error) {
	fls := cfg.srcItf.Methods.List
	mts := make([]*method, 0, len(fls))
	for _, fld := range fls {
		metFld, err := mck.parseItf(cfg, fld)
		if err != nil {
			return nil, err
		}
		for _, met := range metFld {
			// Do not add duplicates. Note that we do not check if
			// the signatures are the same, we relay on the fact that
			// the code is correct.
			if found := findMethod(mts, met.name); found != nil {
				continue
			}
			mts = append(mts, met)
		}
	}
	return mts, nil
}

// parseItf parses code for an interface field, either a method or embedding.
func (mck *Mocker) parseItf(cfg Config, fld *ast.Field) ([]*method, error) {
	switch v := fld.Type.(type) {

	// Interface method.
	case *ast.FuncType:
		met, err := mck.parseFunc(cfg, v)
		if err != nil {
			return nil, err
		}
		met.name = fld.Names[0].Name
		return []*method{met}, nil

	// Embedded interface from the same package.
	case *ast.Ident:
		if v.Obj != nil {
			// From the same file.
			cfg.srcName = v.Obj.Name
			itf, err := mck.run(cfg)
			if err != nil {
				return nil, err
			}
			return itf.methods, nil
		}

		cfg.srcName = v.Name
		itf, err := mck.run(cfg)
		if err != nil {
			return nil, err
		}
		return itf.methods, nil

	// Embedded interface from some other package.
	case *ast.SelectorExpr:
		path := v.X.(*ast.Ident).Name // nolint: forcetypeassert
		pkg, err := cfg.srcFile.findPackage(mck.res, path)
		if err != nil {
			return nil, err
		}

		cfg.srcName = v.Sel.Name
		cfg.srcPkg = pkg
		itf, err := mck.run(cfg)
		if err != nil {
			return nil, err
		}
		return itf.methods, nil
	}

	return nil, fmt.Errorf("unexpected method field type: %T", fld.Type)
}

// parseFunc parses interface method.
func (mck *Mocker) parseFunc(cfg Config, fn *ast.FuncType) (*method, error) {
	var err error
	met := &method{}
	if fn.Params != nil {
		if met.args, err = mck.parseArgs(cfg, fn.Params.List); err != nil {
			return nil, err
		}
	}
	if fn.Results != nil {
		if met.rets, err = mck.parseArgs(cfg, fn.Results.List); err != nil {
			return nil, err
		}
	}
	return met, nil
}

// parseArgs parses method arguments or return values.
func (mck *Mocker) parseArgs(cfg Config, fields []*ast.Field) ([]argument, error) {
	var args []argument
	for _, fld := range fields {
		idents := fld.Names
		if len(idents) == 0 {
			idents = []*ast.Ident{{}}
		}
		for _, ident := range idents {
			exp, err := mck.parseExpr(cfg, fld.Type)
			if err != nil {
				return nil, err
			}
			arg := argument{
				name: ident.Name,
				typ:  exp.value,
				pks:  exp.pks,
			}
			args = append(args, arg)
		}
	}
	return args, nil
}

// parseExpr parses method argument type expression.
//
// nolint: gocognit, cyclop
func (mck *Mocker) parseExpr(cfg Config, e ast.Expr) (expression, error) {
	switch v := e.(type) {

	// Local type (the same package) from a potentially different file.
	case *ast.Ident:
		if _, _, err := cfg.srcPkg.findType(v.Name); err == nil {
			exp := expression{}
			if cfg.srcPkg.pkgPath != cfg.tgtPkg.pkgPath {
				exp.value = cfg.srcPkg.pkgName + "." + v.Name
				exp.pks = append(exp.pks, cfg.srcPkg)
			} else {
				exp.value = v.Name
			}
			return exp, nil
		}

		// If a parameter type is not builtin or local type, it must have been
		// imported by the dot-import.
		if !isBuiltin(v.Name) {
			dots := cfg.srcFile.dotImports()
			for _, pkg := range dots {
				if _, _, err := pkg.findType(v.Name); err == nil {
					exp := expression{}
					if pkg.pkgPath != cfg.tgtPkg.pkgPath {
						exp.value = pkg.pkgName + "." + v.Name
						exp.pks = append(exp.pks, pkg)
					} else {
						exp.value = v.Name
					}
					return exp, nil
				}
			}
			return expression{}, fmt.Errorf("%w: %s", ErrUnkType, v.Name)
		}

		exp := expression{}
		exp.value = v.Name
		return exp, nil

	// Pointer expression, like: *pkg.Type.
	case *ast.StarExpr:
		got, err := mck.parseExpr(cfg, v.X)
		if err != nil {
			return expression{}, err
		}

		exp := expression{}
		exp.value += "*"
		exp.value += got.value
		exp.pks = append(exp.pks, got.pks...)
		return exp, nil

	// Represents a type from some other package. For example, "arg pkg.Type"
	// where "pkg" may be the package name or package import alias.
	case *ast.SelectorExpr:
		pkgName := v.X.(*ast.Ident).Name // nolint: forcetypeassert
		pkg, err := cfg.srcFile.findPackage(mck.res, pkgName)
		if err != nil {
			return expression{}, err
		}
		exp := expression{}
		if pkg.pkgPath != cfg.tgtPkg.pkgPath {
			exp.value = pkgName + "." + v.Sel.Name
			exp.pks = append(exp.pks, pkg)
		} else {
			exp.value = v.Sel.Name
		}
		return exp, nil

	case *ast.MapType:
		got, err := mck.parseExpr(cfg, v.Key)
		if err != nil {
			return expression{}, err
		}

		exp := expression{}
		exp.value += "map[" + got.value + "]"
		exp.pks = append(exp.pks, got.pks...)

		got, err = mck.parseExpr(cfg, v.Value)
		if err != nil {
			return expression{}, err
		}
		exp.value += got.value
		exp.pks = append(exp.pks, got.pks...)
		return exp, nil

	case *ast.ArrayType:
		got, err := mck.parseExpr(cfg, v.Elt)
		if err != nil {
			return expression{}, err
		}
		sb := "[]"
		if v.Len != nil {
			val := v.Len.(*ast.BasicLit).Value // nolint: forcetypeassert
			sb = "[" + val + "]"
		}
		exp := expression{}
		exp.value = sb + got.value
		exp.pks = append(exp.pks, got.pks...)
		return exp, nil

	case *ast.Ellipsis:
		got, err := mck.parseExpr(cfg, v.Elt)
		if err != nil {
			return expression{}, err
		}
		exp := expression{}
		exp.value = "..." + got.value
		exp.pks = append(exp.pks, got.pks...)
		return exp, nil

	// Represents an argument type, which is a function signature.
	// For example, "arg func()".
	case *ast.FuncType:
		met, err := mck.parseFunc(cfg, v)
		if err != nil {
			return expression{}, err
		}
		exp := expression{}
		exp.value = met.genSig("", false)
		exp.pks = append(exp.pks, met.imports()...)
		return exp, nil

	case *ast.ChanType:
		got, err := mck.parseExpr(cfg, v.Value)
		if err != nil {
			return expression{}, err
		}
		ch := "chan"
		switch v.Dir {
		case ast.SEND:
			ch += "<-"
		case ast.RECV:
			ch = "<-" + ch
		}
		exp := expression{}
		exp.value = ch + " " + got.value
		exp.pks = append(exp.pks, got.pks...)
		return exp, nil

	case *ast.IndexExpr:
		gotT, err := mck.parseExpr(cfg, v.X)
		if err != nil {
			return expression{}, err
		}
		gotP, err := mck.parseExpr(cfg, v.Index)
		if err != nil {
			return expression{}, err
		}
		gotT.value = gotT.value + "[" + gotP.value + "]"
		gotT.pks = append(gotT.pks, gotP.pks...)
		return gotT, nil

	case *ast.IndexListExpr:
		gotT, err := mck.parseExpr(cfg, v.X)
		if err != nil {
			return expression{}, err
		}
		gotT.value += "["
		for _, exp := range v.Indices {
			gotP, err := mck.parseExpr(cfg, exp)
			if err != nil {
				return expression{}, err
			}
			gotT.value += gotP.value + ", "
			gotT.pks = append(gotT.pks, gotP.pks...)
		}
		gotT.value = strings.TrimSuffix(gotT.value, ", ") + "]"
		return gotT, nil

	case *ast.InterfaceType:
		if v.Methods != nil && len(v.Methods.List) == 0 {
			return expression{value: "any"}, nil
		}
	}
	return expression{}, ErrAstParse
}

// genConstructor generates code for the mock constructor.
func (mck *Mocker) genConstructor(typeName, testerName string) string {
	const format = "func New%[1]s(t %s.T) *%[1]s {\n" +
		"\tt.Helper()\n" +
		"\treturn &%[1]s{Mock: mock.NewMock(t), t: t}\n" +
		"}"
	return fmt.Sprintf(format, typeName, testerName)
}
